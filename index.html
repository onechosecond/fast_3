<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ㅍast ㅍashion</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Orbit&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* 커서 관련 요소들의 z-index를 최상위로 설정 */
      [data-cursor],
      .cursor,
      .ghost-cursor,
      .cursor-effect,
      div[style*="cursor"],
      body > div[style*="position: fixed"][style*="pointer"],
      canvas[data-cursor],
      svg[data-cursor] {
        z-index: 9999 !important;
      }
    </style>
    <script type="module">
      import { ghostCursor } from "https://unpkg.com/cursor-effects@latest/dist/esm.js";
    
      new ghostCursor();
      
      // 커서 요소의 z-index를 최상위로 설정
      setTimeout(() => {
        const cursorElements = document.querySelectorAll('[id*="cursor"], [class*="cursor"], canvas, svg');
        cursorElements.forEach(el => {
          const style = window.getComputedStyle(el);
          if (style.position === 'fixed' || style.position === 'absolute') {
            el.style.zIndex = '9999';
          }
        });
      }, 100);
      
      // MutationObserver로 동적으로 추가되는 커서 요소 감지
      const observer = new MutationObserver(() => {
        const cursorElements = document.querySelectorAll('[id*="cursor"], [class*="cursor"], canvas, svg');
        cursorElements.forEach(el => {
          const style = window.getComputedStyle(el);
          if (style.position === 'fixed' || style.position === 'absolute') {
            el.style.zIndex = '9999';
          }
        });
      });
      
      observer.observe(document.body, { childList: true, subtree: true });
    </script>
  </head>
  <body class="landing">
    <div class="hover-images-container" id="hover-images-container"></div>
    <main class="panel">
      <p class="eyebrow">Thrift Shopping Simulator</p>
      <h1>이제 새 옷은 그만!</h1>
      <p class="lead">빈티지 옷은 가격도 저렴하고 환경도 지킬 수 있어요.<br>함정을 피해 멋진 빈티지 옷을 고르는 연습을 해보세요!</p>
      <div class="button-row">
        <a class="btn primary" href="play.html">Play</a>
        <a class="btn secondary" href="archive.html">Archive</a>
      </div>
    </main>
    <script>
      (() => {
        function playHoverSound() {
          const audio = new Audio("https://taira-komori.net/sound_os2/game01/select05.mp3");
          audio.volume = 0.5;
          audio.play().catch((err) => {
            console.log("Audio play failed:", err);
          });
        }

        function playClickSound() {
          const audio = new Audio("https://taira-komori.net/sound_os2/game01/poka03.mp3");
          audio.volume = 0.5;
          audio.play().catch((err) => {
            console.log("Audio play failed:", err);
          });
        }

        const buttons = document.querySelectorAll(".button-row .btn");
        buttons.forEach((btn) => {
          btn.addEventListener("mouseenter", playHoverSound);
          btn.addEventListener("click", playClickSound);
        });

        // 마우스 호버 인터랙션 이미지 생성
        const container = document.getElementById("hover-images-container");
        
        // 이미지 호버 시 재생할 소리 목록
        const hoverSounds = [
          "https://taira-komori.net/sound_os2/daily02/magazine1.mp3",
          "https://taira-komori.net/sound_os2/daily02/dumping.mp3",
          "https://taira-komori.net/sound_os2/daily01/shaking_a_crisp_bag1.mp3",
          "https://taira-komori.net/sound_os2/daily02/staple.mp3",
          "https://taira-komori.net/sound_os2/putting01/putting_a_book1.mp3",
          "https://taira-komori.net/sound_os2/putting01/putting_a_book3.mp3",
          "https://taira-komori.net/sound_os2/putting01/lifting_a_bag.mp3",
          "https://taira-komori.net/sound_os2/putting01/lifting_a_garbage_bag.mp3"
        ];

        function playRandomHoverSound() {
          const randomSound = hoverSounds[Math.floor(Math.random() * hoverSounds.length)];
          const audio = new Audio(randomSound);
          audio.volume = 0.3;
          audio.play().catch((err) => {
            console.log("Audio play failed:", err);
          });
        }
        
        // 로컬 tag 이미지 파일 (tag_1.png ~ tag_67.png)
        const totalTagImages = 67;
        
        // 화면 크기에 따라 이미지 개수 동적 계산 (페이지 전체를 뒤덮을 만큼)
        function calculateImageCount() {
          const area = window.innerWidth * window.innerHeight;
          // 평균 이미지 크기 약 330px (240~420px)를 고려하여
          // 화면 영역당 약 15000px²당 이미지 1개로 계산 (겹쳐서 뒤덮을 만큼)
          return Math.max(80, Math.ceil(area / 15000));
        }
        
        const numImages = calculateImageCount();

        // 사용 가능한 이미지 번호 목록 생성 (1부터 67까지)
        let availableTagNumbers = [];
        for (let i = 1; i <= totalTagImages; i++) {
          availableTagNumbers.push(i);
        }

        // 이미지들을 생성하고 랜덤하게 배치
        for (let i = 0; i < numImages; i++) {
          const img = document.createElement("img");
          
          // 사용 가능한 이미지가 없으면 루프 종료
          if (availableTagNumbers.length === 0) {
            break;
          }
          
          // 사용 가능한 이미지 중에서 랜덤하게 선택
          const randomIndex = Math.floor(Math.random() * availableTagNumbers.length);
          const randomTagNumber = availableTagNumbers[randomIndex];
          
          // 선택된 이미지 번호를 목록에서 제거 (한 번만 사용)
          availableTagNumbers.splice(randomIndex, 1);
          img.className = "hover-image";
          img.alt = "hang tag";
          
          // 이미지가 로드된 후 원본 크기의 50%로 설정
          const setImageSize = function() {
            if (this.naturalWidth > 0 && this.naturalHeight > 0) {
              const originalWidth = this.naturalWidth;
              const originalHeight = this.naturalHeight;
              this.style.width = (originalWidth * 0.5) + "px";
              this.style.height = (originalHeight * 0.5) + "px";
            }
          };
          
          img.onload = setImageSize;
          img.src = `tag_${randomTagNumber}.png`;
          
          // 이미 로드된 경우 (캐시된 이미지)
          if (img.complete && img.naturalWidth > 0) {
            setImageSize.call(img);
          }
          
          // 랜덤 위치와 각도 (패널 영역 포함)
          const randomX = Math.random() * window.innerWidth;
          const randomY = Math.random() * window.innerHeight;
          const randomRotation = Math.random() * 360; // 0도 ~ 360도 (더 다양하게)
          
          img.style.left = randomX + "px";
          img.style.top = randomY + "px";
          img.style.transform = `rotate(${randomRotation}deg)`;
          
          // 원본 위치 저장
          img.dataset.originalX = randomX;
          img.dataset.originalY = randomY;
          img.dataset.originalRot = randomRotation;
          img.dataset.currentX = 0;
          img.dataset.currentY = 0;
          
          // 이미지 호버 시 랜덤 소리 재생
          img.addEventListener("mouseenter", playRandomHoverSound);
          
          // 이미지 클릭 방지
          img.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
          });
          
          // 이미지 포인터 이벤트로 클릭 방지 (마우스 다운 이벤트도 차단)
          img.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
          });
          
          container.appendChild(img);
        }

        // 마우스 움직임에 따라 이미지들이 피하도록
        document.addEventListener("mousemove", (e) => {
          const images = document.querySelectorAll(".hover-image");
          const mouseX = e.clientX;
          const mouseY = e.clientY;
          
          images.forEach((img) => {
            const rect = img.getBoundingClientRect();
            const imgCenterX = rect.left + rect.width / 2;
            const imgCenterY = rect.top + rect.height / 2;
            
            // 마우스와 이미지 사이의 거리 계산
            const dx = imgCenterX - mouseX;
            const dy = imgCenterY - mouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // 마우스가 이미지에 가까우면 (225px 이내)
            if (distance < 225) {
              // 이미지를 마우스에서 멀어지게 이동
              const force = (225 - distance) / 225; // 0~1 사이의 값
              const moveX = (dx / distance) * force * 160; // 이동 가능 거리: 160px
              const moveY = (dy / distance) * force * 160; // 이동 가능 거리: 160px
              
              // 현재 위치 가져오기
              let currentX = parseFloat(img.dataset.currentX) || 0;
              let currentY = parseFloat(img.dataset.currentY) || 0;
              
              // 새로운 위치 = 현재 위치 + 이동량 (실제 적용 비율: 0.25)
              const newX = currentX + moveX * 0.25;
              const newY = currentY + moveY * 0.25;
              
              // 현재 위치 업데이트
              img.dataset.currentX = newX;
              img.dataset.currentY = newY;
              
              const originalRot = parseFloat(img.dataset.originalRot);
              
              img.style.transform = `translate(${newX}px, ${newY}px) rotate(${originalRot + force * 20}deg)`;
            }
            // 마우스가 멀어져도 원래 위치로 돌아가지 않음
          });
        });
      })();
    </script>
    <footer class="site-footer">
      <p>&copy; 2025 Seungyoon Lee. All rights reserved.</p>
    </footer>
  </body>
</html>
